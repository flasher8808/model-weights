<!DOCTYPE html>
<html lang="de">
    <head>
    <meta charset="UTF-8" />
    <title>LSTM Next Word Prediction mit TensorFlow.js</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.8.0/dist/tf.min.js"></script>
    </head>
    <body>
        <script>
        let vocab, word2index, index2word, sequenceLength = 4, vocabSize, model;

        // One-Hot-Encoding Funktionen
        function oneHotEncodeSequence(sequence, vocabSize) {
            return sequence.map(idx => {
                const oneHot = new Array(vocabSize).fill(0);
                oneHot[idx] = 1;
                return oneHot;
            });
        }

        function oneHotEncodeTargets(targets, vocabSize) {
            return targets.map(idx => {
                const oneHot = new Array(vocabSize).fill(0);
                oneHot[idx] = 1;
                return oneHot;
            });
        }

        // Funktion um Wortindex in Wort umzuwandeln
        function idx2word(idx) {
            return index2word[idx] || '<unk>';
        }


        async function saveModel() {
            if (!model) {
                console.log('Kein Modell zum Speichern!');
                return;
            }
            await model.save('downloads://lstm-v0');
            saveVocabulary();
            console.log('Modell wurde gespeichert.');
        }

        async function loadModel() {
            const uploadEl = document.getElementById('upload-model');
            if (!uploadEl.files.length) {
                alert('Bitte zuerst Modelldateien auswählen');
                return null;
            }

            const files = Array.from(uploadEl.files);

            files.sort((a, b) => {
                if (a.name.endsWith('.json') && b.name.endsWith('.bin')) return -1;
                if (a.name.endsWith('.bin') && b.name.endsWith('.json')) return 1;
                return 0;
            });

            if (files.length < 2) {
                alert('Bitte beide Dateien (model.json und weights.bin) auswählen!');
                return null;
            }

            if (!files[0].name.endsWith('.json') || !files[1].name.endsWith('.bin')) {
                alert('Bitte sicherstellen, dass zuerst die JSON- und dann die BIN-Datei übergeben werden.');
                return null;
            }

            try {
                const model = await tf.loadLayersModel(tf.io.browserFiles(files));
                alert('Modell erfolgreich geladen!');
                window.model = model;
                console.log(model);
                return model;  // <--- Hier das Modell zurückgeben!
            } catch (e) {
                console.error(e);
                alert('Fehler beim Laden des Modells: ' + e.message);
                return null;
            }
        }

        async function loadModelWeb(modelUrl) {
            if (!modelUrl || typeof modelUrl !== 'string') {
                alert('Bitte eine gültige Modell-URL angeben!');
                return null;
            }

            try {
                const model = await tf.loadLayersModel(modelUrl);
                console.log('Modell erfolgreich via https geladen!');
                window.model = model;
                return model;
            } catch (e) {
                console.error('Fehler beim Laden des Modells:', e);
                alert('Fehler beim Laden des Modells: ' + e.message);
                return null;
            }
        }
        
        function saveVocabulary() {
            const vocabData = JSON.stringify({ word2index, index2word, vocab });
            const blob = new Blob([vocabData], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "vocab.json";
            a.click();
            URL.revokeObjectURL(url);
        }

        async function loadVocabulary(file) {
            const text = await file.text();
            const data = JSON.parse(text);
            word2index = data.word2index;
            index2word = data.index2word;
            vocab = data.vocab;
            vocabSize = vocab.length;
        }

        // --- Modell bauen ---
        function createModel(sequenceLength, vocabSize) {
            model = tf.sequential();

            model.add(tf.layers.lstm({
                units: 100,
                returnSequences: true,
                inputShape: [sequenceLength, vocabSize]
            }));

            model.add(tf.layers.lstm({
                units: 100,
                returnSequences: false
            }));

            model.add(tf.layers.dense({
                units: vocabSize,
                activation: 'softmax'
            }));

            const optimizer = tf.train.adam(0.01);

            model.compile({
                optimizer,
                loss: 'categoricalCrossentropy',
                metrics: ['accuracy']
            });

            return model;
        }

        // --- Datenvorbereitung ---
        // 1. Beispiel-Text (hier: klein halten, ersetze durch deinen Text)
        const text = `Der Computer ist Knecht. Eines Sommers waren einige Leute, wie sie zu tun pflegten, zum Fischen
                        auf Selö im Reydarfjord. Und es traf sich, als der getrocknete Fisch
                        ans Land gebracht wurde, daß ein großer Teil der Fische des Pfarrers
                        von Holme in der Fischbude zurückblieb. Das Wetter verschlechterte sich
                        in dem Maße, daß man an die Fische nicht herankonnte, bis im Herbst
                        wieder gutes Seewetter wurde. Da zogen sie hinaus, um sie zu holen
                        und begannen sofort, die Fische aus der Hütte ins Boot zu tragen. Die
                        Bootsleute sagten, sie würden gern nach der anderen Seite der Insel
                        gehen, um nachzusehen, ob etwas ans Land getrieben sei. Einer von
                        ihnen erklärte sich bereit zu gehen, während die anderen die Fische
                        hinuntertrugen. Er ging also, und die anderen trugen die Beute in das
                        Boot. Plötzlich stieg das Wasser so gewaltig, daß es ihnen nur mit
                        knapper Not gelang, die Fische in das Boot zu schleppen. Sie schifften
                        sich alle ein und warteten eine Weile auf den Abwesenden; als er aber
                        kam, war es der Brandung wegen unmöglich, ihn ins Boot zu ziehen; da
                        riefen sie ihm zu, daß er nun dableiben müßte, sie würden ihn aber am
                        nächsten Tag holen, wenn Seewetter wäre. Sie glaubten wohl, daß es am
                        besten sei, an ihr eigenes Leben zu denken, und steuerten dem Lande zu;
                        er aber blieb hilflos zurück. Der Computer ist Knecht.

                        Es stellten sich Tauschnee und Windstille ein, und der Mann ging
                        deshalb nach der Fischerhütte, ohne einen Ausweg zu wissen, und dort
                        blieb er bis zum Abend. Da begann er zu verzweifeln und dachte, es
                        läge ihm näher, sich das Leben zu nehmen, als dort Hungers zu sterben,
                        und er lief aus der Hütte hinaus. Da entdeckte er einen freundlichen
                        Stern; er glaubte aber, daß es in dieser wolkenschwarzen Nacht kein
                        Himmelsstern sein könnte, und als er anfing, genauer hinzusehen, schien
                        er ihm einem Licht in einem Fenster zu ähneln. Er lief eine kleine
                        Weile, bis er an ein Haus kam, das so prächtig war, daß es einer
                        Königshalle glich. Er hörte, wie drinnen gesagt wurde: Der Computer ist Knecht.`;

        // Tokenize: Kleinschreibung, Satzzeichen entfernen, Split auf Leerzeichen
        const tokens = text.toLowerCase()
            .replace(/[^\w\s]/g, '')  // Satzzeichen entfernen
            .split(/\s+/)
            .filter(t => t.length > 0);

        console.log("Tokens:", tokens);

        // Vokabular erstellen
        function buildVocabulary(tokens) {
            const wordSet = new Set(tokens);
            vocab = Array.from(wordSet);
            word2index = {};
            index2word = {};
            vocab.forEach((word, idx) => {
                word2index[word] = idx;
                index2word[idx] = word;
            });
            return { word2index, index2word, vocab };
        }



        async function createModelAndTrain () {
            
            ({ word2index, index2word, vocab } = buildVocabulary(tokens));
            vocabSize = vocab.length;

            console.log("Vokabulargröße:", vocabSize);

            // Parameter: Länge der Eingabesequenz (Wörter)
            //const sequenceLength = 4;

            // Sequenzen erzeugen für Training
            function createSequences(tokens, word2index, sequenceLength) {
            const inputs = [];
            const targets = [];
            for(let i = 0; i < tokens.length - sequenceLength; i++) {
                const inputSeq = tokens.slice(i, i + sequenceLength).map(w => word2index[w]);
                const target = word2index[tokens[i + sequenceLength]];
                inputs.push(inputSeq);
                targets.push(target);
            }
            return { inputs, targets };
            }

            const { inputs, targets } = createSequences(tokens, word2index, sequenceLength);
            console.log("Anzahl Trainingsbeispiele:", inputs.length);

            
            // One-Hot Kodierung der Inputs und Targets
            const xOneHot = inputs.map(seq => oneHotEncodeSequence(seq, vocabSize));
            const yOneHot = oneHotEncodeTargets(targets, vocabSize);

            // In Tensoren umwandeln
            const xTrain = tf.tensor3d(xOneHot);   // [Samples, sequenceLength, vocabSize]
            const yTrain = tf.tensor2d(yOneHot);   // [Samples, vocabSize]

            

            model = createModel(sequenceLength, vocabSize);
            model.summary();

            // --- Training ---

            const epochs = 30;
            const batchSize = 32;

            await model.fit(xTrain, yTrain, {
            epochs,
            batchSize,
            shuffle: true,
            callbacks: {
                onEpochEnd: (epoch, logs) => {
                console.log(`Epoch ${epoch + 1}/${epochs} - Loss: ${logs.loss.toFixed(4)}, Accuracy: ${logs.acc || logs.accuracy}`);
                }
            }
            });

            //await model.save('indexeddb://lstm-modell-v1');
            //await saveModel();

            // Speicher freigeben
            xTrain.dispose();
            yTrain.dispose();
        }

        async function loadAndPrepareModel() {
            model = await loadModelWeb('https\:\/\/flasher8808.github.io/model-weights/mein-lstm-modell.json');
            if (!model) {
                alert('Kein Modell zum Generieren geladen!');
                return false;
            }
            ({ word2index, index2word, vocab } = buildVocabulary(tokens));
            vocabSize = vocab.length;
            return true;
        }


        async function generateText(seedText, numWordsToGenerate, topN = 5) {

            if (!model) {
                const loaded = await loadAndPrepareModel();
                if (!loaded) return;
            }

            let currentTokens = seedText.toLowerCase()
                .replace(/[^\w\s]/g, '')
                .split(/\s+/)
                .filter(t => t.length > 0);

            console.log('Seed:', currentTokens.join(' '));

            for (let i = 0; i < numWordsToGenerate; i++) {
                let inputSeq = currentTokens.slice(-sequenceLength);

                if (inputSeq.length < sequenceLength) {
                    const padLength = sequenceLength - inputSeq.length;
                    inputSeq = new Array(padLength).fill(vocab[0]).concat(inputSeq);
                }

                const inputIdx = inputSeq.map(w => word2index[w] !== undefined ? word2index[w] : 0);

                const inputOH = oneHotEncodeSequence(inputIdx, vocabSize);
                const inputTensor = tf.tensor([inputOH]);

                const prediction = model.predict(inputTensor);  // Form: [1, vocabSize] evtl

                // Erhalte das Wahrscheinlichkeitsarray (Float32Array)
                const predictionData = await prediction.data();

                // predictionData ist Array mit Wahrscheinlichkeiten für jedes Wort im Vokabular

                // Finde die Top N Wahrscheinlichkeiten und deren Indizes
                const topIndices = Array.from(predictionData.keys())
                    .map(i => ({index: i, prob: predictionData[i]}))
                    .sort((a, b) => b.prob - a.prob)
                    .slice(0, topN);

                console.log('Top Worte und Wahrscheinlichkeiten:', topIndices.map(item => ({
                    word: idx2word(item.index),
                    probability: item.prob
                })));

                for (let j = 0; j < topIndices.length; j++) {
                    document.getElementById("pred" + (j+1)).textContent = idx2word(topIndices[j].index);
                    document.getElementById("pred" + (j+1) + "prob").textContent = (topIndices[j].prob * 100).toFixed(1);
                    //console.log(idx2word(topIndices[j].index));
                    //console.log(topIndices[j].index);
                    //console.log(topIndices[j].prob);
                }

                // Nimm als nächsten Schritt das wahrscheinlichste Wort
                const predictedIdx = topIndices[0].index;
                const predictedWord = idx2word(predictedIdx);

                currentTokens.push(predictedWord);

                prediction.dispose();
                inputTensor.dispose();
            }

            //console.log('Generierter Text:', currentTokens.join(' '));
            //document.getElementById("user_prompt").value = currentTokens.join(' ');
            //return currentTokens.join(' ');
        }

        async function generateAutoText(seedText, numWordsToGenerate, topN = 5) {

            for (let i = 0; i < numWordsToGenerate; i++) {
                appendPred(document.getElementById('pred1').textContent);
                //generateText(document.getElementById('user_prompt').value, 1);
            }
        }

        // Beispielaufruf:
        //generateText('das ist ein beispieltext', 10);

        function appendPred (word) {
            if (document.getElementById("user_prompt").value.length == 0) {
                document.getElementById("user_prompt").value = word;
            } else {
                document.getElementById("user_prompt").value = document.getElementById("user_prompt").value + " " + word;
            }
            
            generateText(document.getElementById('user_prompt').value, 1)
        }

        function resetPred () {
            document.getElementById("user_prompt").value = "";

            for (let i = 0; i < 5; i++) {
                document.getElementById("pred" + (i + 1)).textContent = "";
                document.getElementById("pred" + (i + 1) + "prob").textContent = "";
            }
        }

        // DOM-Aufbau abwarten - Eventlistener für Anklicken der Worte
        document.addEventListener("DOMContentLoaded", function() {
            document.getElementById("pred1").addEventListener("click", function() {
                let word = document.getElementById("pred1").textContent.trim(); // trim für Leerzeichen entfernen
                if (word.length > 0) {
                    appendPred(word);
                } else {
                    // Optional: Kein Wort vorhanden, nichts tun oder Hinweis anzeigen
                    console.log("Kein Wort zum Verarbeiten.");
                    alert("Bitte zuerst einen Prompt eingeben oder die Vorhersagt ohne Prompt starten");
                }
            });

            document.getElementById("pred2").addEventListener("click", function() {
                let word = document.getElementById("pred2").textContent.trim(); // trim für Leerzeichen entfernen
                if (word.length > 0) {
                    appendPred(word);
                } else {
                    // Optional: Kein Wort vorhanden, nichts tun oder Hinweis anzeigen
                    console.log("Kein Wort zum Verarbeiten.");
                    alert("Bitte zuerst einen Prompt eingeben oder die Vorhersagt ohne Prompt starten");
                }
            });

            document.getElementById("pred3").addEventListener("click", function() {
                let word = document.getElementById("pred3").textContent.trim(); // trim für Leerzeichen entfernen
                if (word.length > 0) {
                    appendPred(word);
                } else {
                    // Optional: Kein Wort vorhanden, nichts tun oder Hinweis anzeigen
                    console.log("Kein Wort zum Verarbeiten.");
                    alert("Bitte zuerst einen Prompt eingeben oder die Vorhersagt ohne Prompt starten");
                }
            });

            document.getElementById("pred4").addEventListener("click", function() {
                let word = document.getElementById("pred4").textContent.trim(); // trim für Leerzeichen entfernen
                if (word.length > 0) {
                    appendPred(word);
                } else {
                    // Optional: Kein Wort vorhanden, nichts tun oder Hinweis anzeigen
                    console.log("Kein Wort zum Verarbeiten.");
                    alert("Bitte zuerst einen Prompt eingeben oder die Vorhersagt ohne Prompt starten");
                }
            });

            document.getElementById("pred5").addEventListener("click", function() {
                let word = document.getElementById("pred5").textContent.trim(); // trim für Leerzeichen entfernen
                if (word.length > 0) {
                    appendPred(word);
                } else {
                    // Optional: Kein Wort vorhanden, nichts tun oder Hinweis anzeigen
                    console.log("Kein Wort zum Verarbeiten.");
                    alert("Bitte zuerst einen Prompt eingeben oder die Vorhersagt ohne Prompt starten");
                }
            });
        });
        
        </script>
        <h1>LSTM-Modell</h1>

        <h2>Modell erstellen und trainieren</h2>
        <button onclick="createModelAndTrain()">Modell trainieren</button>
        <button onclick="saveModel()">Modell speichern</button>
        <input type="file" id="upload-model" multiple />
        <button onclick="loadModel()">Modell laden</button>
        <button onclick="loadModelWeb('https\:\/\/flasher8808.github.io/model-weights/mein-lstm-modell.json')">Modell laden extern</button>
        <input type="file" id="upload-vocab" />
        <button onclick="loadVocabulary(document.getElementById('upload-vocab').files[0])">Vokabular laden</button>
        <h2>Modell verwenden</h2>
        <p>Prompt eingeben: </p><input type="text" id="user_prompt" style="width: 1500px;" />
        <button type="button" onclick="generateText(document.getElementById('user_prompt').value, 1)">Vorhersage starten</button> 
        <button type="button" onclick="appendPred(document.getElementById('pred1').textContent)">Weiter</button>
        <button type="button" onclick="generateAutoText(document.getElementById('user_prompt').value, 3)">Auto / Stopp</button>
        <button type="button" onclick="resetPred()">Reset</button>
        <!--<p>Beispielaufruf mit dem Halbsatz "das ist ein beispieltext" und einer Vorhersage von 10 Worten:</p>-->
        
        <p id="vorhersage"></p>
        <br/>
        <h2>Vorhersage nächste Wörter</h2>
        <table border="1">
            <thead>
                <tr>
                <th></th>
                <th>Wort</th>
                <th>Wahrscheinlichkeit</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                <td>1</td>
                <td id="pred1"></td>
                <td id="pred1prob"></td>
                </tr>
                <tr>
                <td>2</td>
                <td id="pred2"></td>
                <td id="pred2prob"></td>
                </tr>
                <tr>
                <td>3</td>
                <td id="pred3"></td>
                <td id="pred3prob"></td>
                </tr>
                <tr>
                <td>4</td>
                <td id="pred4"></td>
                <td id="pred4prob"></td>
                </tr>
                <tr>
                <td>5</td>
                <td id="pred5"></td>
                <td id="pred5prob"></td>
                </tr>
            </tbody>
        </table>

        <p id="pred1"></p>
        <p id="pred2"></p>
        <p id="pred3"></p>
        <p id="pred4"></p>
        <p id="pred5"></p>
        <br/>
        <br/>
        <p>start xampp: sudo /opt/lampp/lampp start</p>
    </body>
</html>




